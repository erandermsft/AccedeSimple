{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "AI in .NET Walkthrough",
  "steps": [
    {
      "file": "src/AccedeSimple.Service/Endpoints.cs",
      "description": "Structured data is handled by Microsoft.Extensions.AI for you",
      "line": 160,
      "contents": "#pragma warning disable\r\nusing System.Collections.Concurrent;\r\nusing System.Text.Json;\r\nusing System.Threading.Channels;\r\nusing AccedeSimple.Domain;\r\nusing AccedeSimple.Service.ProcessSteps;\r\nusing AccedeSimple.Service.Services;\r\nusing Azure.Storage.Blobs;\r\nusing Azure.Storage.Sas;\r\nusing Microsoft.AspNetCore.Http.Features;\r\nusing Microsoft.AspNetCore.Mvc;\r\nusing Microsoft.Extensions.AI;\r\nusing Microsoft.Extensions.Options;\r\nusing Microsoft.SemanticKernel;\r\nusing OpenTelemetry.Trace;\r\nusing TextContent = Microsoft.Extensions.AI.TextContent;\r\n\r\nnamespace AccedeSimple.Service;\r\npublic static class Endpoints\r\n{\r\n\r\n    public static void MapEndpoints(this WebApplication app)\r\n    {\r\n        app.MapEndpoints(\"/api/admin\", group => group.MapAdminEndpoints());\r\n        app.MapEndpoints(\"/api/chat\", group => group.MapChatEndpoints());\r\n    }\r\n\r\n    private static void MapEndpoints(this WebApplication app, string basePath, Action<RouteGroupBuilder> configure)\r\n    {\r\n        var group = app.MapGroup(basePath);\r\n        configure(group);\r\n    }\r\n\r\n    private static void MapAdminEndpoints(this RouteGroupBuilder group)\r\n    {\r\n        // var group = app.MapGroup(\"/api/admin\");\r\n\r\n        // Get pending trip approval requests\r\n        group.MapGet(\"/requests\", async (\r\n            [FromServices] StateStore store,\r\n            [FromServices] ILogger<Program> logger, \r\n            CancellationToken cancellationToken) =>\r\n        {\r\n            try\r\n            {\r\n                var requests = store.Get(\"trip-requests\").Value as List<TripRequest>;\r\n                return Results.Ok(requests);\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                logger.LogError(ex, \"Error fetching trip requests\");\r\n                return Results.Problem(\"Error fetching trip requests\", statusCode: 500);\r\n            }\r\n        });\r\n\r\n        // Approve or reject a trip request\r\n        group.MapPost(\"/requests/approval\", async (\r\n            [FromServices] Kernel kernel, \r\n            [FromServices] KernelProcess process, \r\n            [FromServices] ILogger<Program> logger,\r\n            TripRequestResult result, \r\n            CancellationToken cancellationToken) =>\r\n        {\r\n            try\r\n            {\r\n                await process.StartAsync(kernel, new KernelProcessEvent { Id = nameof(ApprovalStep.HandleApprovalResponseAsync), Data = result });\r\n                return Results.Ok();\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                logger.LogError(ex, \"Error submitting trip request result\");\r\n                return Results.Problem(\"Error submitting trip request result\", statusCode: 500);\r\n            }\r\n        });        \r\n    }\r\n\r\n    private static void MapChatEndpoints(this RouteGroupBuilder group)\r\n    {\r\n\r\n        // Stream responses back to the client\r\n        group.MapGet(\"/stream\", async (\r\n            int? startIndex, \r\n            [FromServices] ChatStream chatStream, \r\n            HttpResponse response, \r\n            CancellationToken cancellationToken) => \r\n        {\r\n            // Create a channel to handle incoming messages\r\n            var channel = Channel.CreateUnbounded<ChatItem>();\r\n\r\n            // Disable response buffering\r\n            var bufferingFeature = response.HttpContext.Features.Get<IHttpResponseBodyFeature>();\r\n            bufferingFeature?.DisableBuffering();    \r\n\r\n            // Set SSE headers\r\n            response.Headers.Add(\"Content-Type\", \"text/event-stream\");\r\n            response.Headers.Add(\"Cache-Control\", \"no-cache, no-store\");\r\n            response.Headers.Add(\"Connection\", \"keep-alive\");\r\n\r\n            // Initialize connected event\r\n            await response.WriteAsync($\"event: connected\\ndata: {{\\\"connected\\\": true}}\\n\\n\", cancellationToken);\r\n            await response.Body.FlushAsync(cancellationToken);\r\n            try\r\n            {\r\n                // Subscribe to the chat stream\r\n                var subscription = \r\n                    chatStream\r\n                        .Messages\r\n                        .Subscribe(msg => channel.Writer.TryWrite(msg));\r\n\r\n                // Read from the channel and write to the response\r\n                await foreach (var chatItem in channel.Reader.ReadAllAsync(cancellationToken))\r\n                {\r\n                    // Check if the message is visible to the user\r\n                    if (chatItem.IsUserVisible)\r\n                    {\r\n                        // Handle the message\r\n                        await HandleMessageAsync(chatItem, response, cancellationToken);\r\n                    }\r\n                }\r\n\r\n                await response.WriteAsync($\"event: complete\\ndata: {{}}\\n\\n\", cancellationToken);\r\n                await response.Body.FlushAsync(cancellationToken);               \r\n            \r\n                // Wait for the cancellation token to be triggered\r\n                await Task.Delay(Timeout.Infinite, cancellationToken);\r\n            }\r\n            catch (Exception ex) {\r\n                // Handle any exceptions that occur during streaming\r\n                await response.WriteAsync($\"event: error\\ndata: {{\\\"error\\\": \\\"{ex.Message}\\\"}}\\n\\n\", cancellationToken);\r\n                await response.Body.FlushAsync(cancellationToken);\r\n            }\r\n        });\r\n\r\n\r\n        // Handle incoming messages\r\n        group.MapPost(\"/messages\", async (\r\n            HttpRequest request, \r\n            [FromKeyedServices(\"uploads\")] BlobServiceClient blobServiceClient, \r\n            [FromServices] IChatClient chatClient, \r\n            [FromServices] MessageService messageService,\r\n            [FromServices] ProcessService processService, \r\n            [FromServices] ChatStream chatStream,\r\n            [FromServices] IOptions<UserSettings> userSettings, \r\n            CancellationToken cancellationToken) => \r\n        {\r\n\r\n            // Read request body\r\n            var bodyText = request.Form[\"Text\"].FirstOrDefault() ?? \"\";\r\n            var uploads = await GetFileUploads(userSettings.Value.UserId, request, blobServiceClient, cancellationToken);\r\n\r\n            // Create user message\r\n            var userMessage = new UserMessage(bodyText)\r\n            {\r\n                Attachments = uploads,\r\n                Id = Guid.NewGuid().ToString(),\r\n            };\r\n            \r\n            await messageService.AddMessageAsync(userMessage, userSettings.Value.UserId);\r\n\r\n            // Identify the user's intent\r\n            var reason = await chatClient.GetResponseAsync<UserIntent>($\"Get the user intent: {userMessage.Text}\");\r\n            \r\n            reason.TryGetResult(out var intentResult);\r\n\r\n            // Add the message to the chat stream\r\n            await processService.ActAsync(intentResult, userMessage);\r\n\r\n            return Results.Ok();\r\n        });\r\n\r\n        // TODO: This should enable chat to be restored from history\r\n        group.MapGet(\"/messages\", async (\r\n            [FromKeyedServices(\"history\")] ConcurrentDictionary<string, List<ChatItem>> history,\r\n            [FromServices] ChatStream chatStream,\r\n            [FromQuery] string? userId) =>\r\n        {\r\n            if (string.IsNullOrEmpty(userId))\r\n            {\r\n                return Results.BadRequest(\"User ID is required\");\r\n            }\r\n\r\n            if (!history.TryGetValue(userId, out var messages))\r\n            {\r\n                return Results.NotFound(\"No messages found for the specified user ID\");\r\n            }\r\n\r\n            var visibleMessages = messages.Where(m => m.IsUserVisible).ToList();\r\n            \r\n            return Results.Ok(visibleMessages);\r\n\r\n        });\r\n\r\n        group.MapPost(\"/stream/cancel\", async () =>\r\n        {\r\n            // TODO: Cancel the stream\r\n\r\n            return Results.Ok();\r\n        });\r\n\r\n        \r\n        group.MapPost(\"/messages/clear\", async (\r\n            [FromKeyedServices(\"history\")] ConcurrentDictionary<string, List<ChatItem>> history,\r\n            [FromQuery] string? userId) =>\r\n        {\r\n            if (string.IsNullOrEmpty(userId))\r\n            {\r\n                return Results.BadRequest(\"User ID is required\");\r\n            }\r\n\r\n            // Clear history for the specified user ID\r\n            if (history.TryRemove(userId, out _))\r\n            {\r\n                return Results.Ok(\"History cleared\");\r\n            }\r\n            else\r\n            {\r\n                return Results.NotFound(\"No history found for the specified user ID\");\r\n            }\r\n        });\r\n\r\n        // Select an itinerary option\r\n        group.MapPost(\"/select-itinerary\", async (\r\n            [FromServices] MessageService messageService,\r\n            [FromServices] ProcessService processService,\r\n            [FromServices] ILogger<Program> logger,\r\n            [FromServices] IOptions<UserSettings> userSettings,\r\n            SelectItineraryRequest request,\r\n            CancellationToken cancellationToken) =>\r\n        {\r\n            try \r\n            {\r\n\r\n                var input = new ItinerarySelectedChatItem($\"I have selected an itinerary option. {request.OptionId}\")\r\n                {\r\n                    MessageId = request.MessageId,\r\n                    OptionId = request.OptionId\r\n                };\r\n                \r\n                await messageService.AddMessageAsync(input, userSettings.Value.UserId);\r\n\r\n                await processService.ActAsync(UserIntent.StartTripApproval, input);\r\n\r\n                return Results.Ok();\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                logger.LogError(ex, \"Error selecting itinerary\");\r\n                return Results.Problem(\"Error selecting itinerary\", statusCode: 500);\r\n            }\r\n        });                        \r\n    }\r\n\r\n    private static ChatMessage CreateChatMessageWithAttachments(List<UriAttachment> attachments, string text)\r\n    {\r\n        var content = new List<AIContent>(attachments.Count + 1) { new TextContent(text) };\r\n        foreach (var attachment in attachments)\r\n        {\r\n            if (attachment.Uri.StartsWith(\"data:\"))\r\n            {\r\n                content.Add(new DataContent(attachment.Uri, attachment.ContentType));\r\n            }\r\n            else\r\n            {\r\n                content.Add(new UriContent(attachment.Uri, attachment.ContentType));\r\n            }\r\n        }\r\n\r\n        return new ChatMessage(ChatRole.User, content);\r\n    }\r\n\r\n    private static async Task HandleMessageAsync(ChatItem chatItem, HttpResponse response, CancellationToken cancellationToken)\r\n    {\r\n        try\r\n        {\r\n\r\n            // Handle the message based on its type\r\n            if (chatItem is AssistantResponse assistantResponse)\r\n            {\r\n                // Handle assistant response\r\n                await response.WriteAsync($\"data: {JsonSerializer.Serialize(assistantResponse, JsonSerializerOptions.Web)}\\n\\n\", cancellationToken);\r\n                await response.Body.FlushAsync(cancellationToken);\r\n            }\r\n            else if (chatItem is CandidateItineraryChatItem itineraryItem)\r\n            {\r\n                // Handle candidate itinerary\r\n                var serializedMessage = JsonSerializer.Serialize(itineraryItem, JsonSerializerOptions.Web);\r\n                await response.WriteAsync($\"data: {serializedMessage}\\n\\n\", cancellationToken);\r\n                await response.Body.FlushAsync(cancellationToken);\r\n            }\r\n            else if (chatItem is TripRequestUpdated tripRequestUpdated)\r\n            {\r\n                // Handle trip request update\r\n                var serializedMessage = JsonSerializer.Serialize(tripRequestUpdated, JsonSerializerOptions.Web);\r\n                await response.WriteAsync($\"data: {serializedMessage}\\n\\n\", cancellationToken);\r\n                await response.Body.FlushAsync(cancellationToken);\r\n            }\r\n            else if (chatItem is TripRequestDecisionChatItem tripDecision)\r\n            {\r\n                // Handle trip request decision\r\n                var serializedMessage = JsonSerializer.Serialize(tripDecision, JsonSerializerOptions.Web);\r\n                await response.WriteAsync($\"data: {serializedMessage}\\n\\n\", cancellationToken);\r\n                await response.Body.FlushAsync(cancellationToken);\r\n            }\r\n\r\n            // Handle completion\r\n            await response.WriteAsync($\"event: complete\\ndata: {{}}\\n\\n\", cancellationToken);\r\n            await response.Body.FlushAsync(cancellationToken);\r\n        }\r\n        catch (OperationCanceledException) { }\r\n    }\r\n\r\n    private static async Task<List<UriAttachment>> GetFileUploads(string userId, HttpRequest request, BlobServiceClient blobServiceClient, CancellationToken cancellationToken)\r\n    {\r\n        List<UriAttachment> results = [];\r\n        if (request.HasFormContentType && request.Form.Files.Count > 0)\r\n        {\r\n            foreach (var file in request.Form.Files)\r\n            {\r\n                if (blobServiceClient.AccountName == \"devstoreaccount1\")\r\n                {\r\n                    // These URIs are sent to LLM APIs, which don't have access to the local storage emulator, so we need to convert\r\n                    // them to data URIs in that case.\r\n                    results.Add(new(await ConvertToDataUri(file.OpenReadStream(), file.ContentType, cancellationToken), file.ContentType));\r\n                }\r\n                else\r\n                {\r\n                    results.Add(await UploadToBlobContainerAsync(userId, blobServiceClient, file, cancellationToken));\r\n                }\r\n            }\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    private static async Task<UriAttachment> UploadToBlobContainerAsync(string userId, BlobServiceClient blobServiceClient, IFormFile file, CancellationToken cancellationToken)\r\n    {\r\n        var containerClient = blobServiceClient.GetBlobContainerClient(\"user-content\");\r\n        await containerClient.CreateIfNotExistsAsync(cancellationToken: cancellationToken);\r\n\r\n        var extension = Path.GetExtension(file.FileName) ?? \"jpg\";\r\n        var blobClient = containerClient.GetBlobClient($\"{userId}/{Guid.CreateVersion7():N}.{extension}\");\r\n        await using var stream = file.OpenReadStream();\r\n        await blobClient.UploadAsync(stream, overwrite: true, cancellationToken);\r\n\r\n        var sasBuilder = new BlobSasBuilder\r\n        {\r\n            BlobContainerName = containerClient.Name,\r\n            BlobName = blobClient.Name,\r\n            Resource = \"b\",\r\n            ExpiresOn = DateTimeOffset.MaxValue,\r\n        };\r\n\r\n        sasBuilder.SetPermissions(BlobSasPermissions.Read);\r\n\r\n        if (blobClient.CanGenerateSasUri)\r\n        {\r\n            return new(blobClient.GenerateSasUri(sasBuilder).ToString(), file.ContentType);\r\n        }\r\n        else\r\n        {\r\n            var userDelegationKey = blobServiceClient.GetUserDelegationKey(DateTimeOffset.UtcNow,\r\n                                                                        DateTimeOffset.UtcNow.AddHours(2));\r\n            var blobUriBuilder = new BlobUriBuilder(blobClient.Uri)\r\n            {\r\n                Sas = sasBuilder.ToSasQueryParameters(userDelegationKey, blobServiceClient.AccountName)\r\n            };\r\n\r\n            return new(blobUriBuilder.ToUri().ToString(), file.ContentType);\r\n        }\r\n\r\n        // return new(blobClient.GenerateSasUri(sasBuilder).ToString(), file.ContentType);\r\n    }\r\n\r\n    private static async ValueTask<string> ConvertToDataUri(Stream stream, string contentType, CancellationToken cancellationToken)\r\n    {\r\n        using var memoryStream = new MemoryStream();\r\n        await stream.CopyToAsync(memoryStream, cancellationToken);\r\n        var base64 = Convert.ToBase64String(memoryStream.ToArray());\r\n        return $\"data:{contentType};base64,{base64}\";\r\n    }\r\n\r\n    public record SelectItineraryRequest(string MessageId, string OptionId);    \r\n\r\n    public readonly record struct UriAttachment(string Uri, string ContentType);\r\n}\r\n#pragma warning restore"
    },
    {
      "file": "src/AccedeSimple.Service/Endpoints.cs",
      "description": "Simply by using the generic override (actually an extension method) of GetResponseAsync, the extensions for AI code will handle everything necessary to ensure a schema is passed and structured data is returned. This helps constrain the model and provide information in a format that is ready to parse.",
      "line": 161,
      "contents": "#pragma warning disable\r\nusing System.Collections.Concurrent;\r\nusing System.Text.Json;\r\nusing System.Threading.Channels;\r\nusing AccedeSimple.Domain;\r\nusing AccedeSimple.Service.ProcessSteps;\r\nusing AccedeSimple.Service.Services;\r\nusing Azure.Storage.Blobs;\r\nusing Azure.Storage.Sas;\r\nusing Microsoft.AspNetCore.Http.Features;\r\nusing Microsoft.AspNetCore.Mvc;\r\nusing Microsoft.Extensions.AI;\r\nusing Microsoft.Extensions.Options;\r\nusing Microsoft.SemanticKernel;\r\nusing OpenTelemetry.Trace;\r\nusing TextContent = Microsoft.Extensions.AI.TextContent;\r\n\r\nnamespace AccedeSimple.Service;\r\npublic static class Endpoints\r\n{\r\n\r\n    public static void MapEndpoints(this WebApplication app)\r\n    {\r\n        app.MapEndpoints(\"/api/admin\", group => group.MapAdminEndpoints());\r\n        app.MapEndpoints(\"/api/chat\", group => group.MapChatEndpoints());\r\n    }\r\n\r\n    private static void MapEndpoints(this WebApplication app, string basePath, Action<RouteGroupBuilder> configure)\r\n    {\r\n        var group = app.MapGroup(basePath);\r\n        configure(group);\r\n    }\r\n\r\n    private static void MapAdminEndpoints(this RouteGroupBuilder group)\r\n    {\r\n        // var group = app.MapGroup(\"/api/admin\");\r\n\r\n        // Get pending trip approval requests\r\n        group.MapGet(\"/requests\", async (\r\n            [FromServices] StateStore store,\r\n            [FromServices] ILogger<Program> logger, \r\n            CancellationToken cancellationToken) =>\r\n        {\r\n            try\r\n            {\r\n                var requests = store.Get(\"trip-requests\").Value as List<TripRequest>;\r\n                return Results.Ok(requests);\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                logger.LogError(ex, \"Error fetching trip requests\");\r\n                return Results.Problem(\"Error fetching trip requests\", statusCode: 500);\r\n            }\r\n        });\r\n\r\n        // Approve or reject a trip request\r\n        group.MapPost(\"/requests/approval\", async (\r\n            [FromServices] Kernel kernel, \r\n            [FromServices] KernelProcess process, \r\n            [FromServices] ILogger<Program> logger,\r\n            TripRequestResult result, \r\n            CancellationToken cancellationToken) =>\r\n        {\r\n            try\r\n            {\r\n                await process.StartAsync(kernel, new KernelProcessEvent { Id = nameof(ApprovalStep.HandleApprovalResponseAsync), Data = result });\r\n                return Results.Ok();\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                logger.LogError(ex, \"Error submitting trip request result\");\r\n                return Results.Problem(\"Error submitting trip request result\", statusCode: 500);\r\n            }\r\n        });        \r\n    }\r\n\r\n    private static void MapChatEndpoints(this RouteGroupBuilder group)\r\n    {\r\n\r\n        // Stream responses back to the client\r\n        group.MapGet(\"/stream\", async (\r\n            int? startIndex, \r\n            [FromServices] ChatStream chatStream, \r\n            HttpResponse response, \r\n            CancellationToken cancellationToken) => \r\n        {\r\n            // Create a channel to handle incoming messages\r\n            var channel = Channel.CreateUnbounded<ChatItem>();\r\n\r\n            // Disable response buffering\r\n            var bufferingFeature = response.HttpContext.Features.Get<IHttpResponseBodyFeature>();\r\n            bufferingFeature?.DisableBuffering();    \r\n\r\n            // Set SSE headers\r\n            response.Headers.Add(\"Content-Type\", \"text/event-stream\");\r\n            response.Headers.Add(\"Cache-Control\", \"no-cache, no-store\");\r\n            response.Headers.Add(\"Connection\", \"keep-alive\");\r\n\r\n            // Initialize connected event\r\n            await response.WriteAsync($\"event: connected\\ndata: {{\\\"connected\\\": true}}\\n\\n\", cancellationToken);\r\n            await response.Body.FlushAsync(cancellationToken);\r\n            try\r\n            {\r\n                // Subscribe to the chat stream\r\n                var subscription = \r\n                    chatStream\r\n                        .Messages\r\n                        .Subscribe(msg => channel.Writer.TryWrite(msg));\r\n\r\n                // Read from the channel and write to the response\r\n                await foreach (var chatItem in channel.Reader.ReadAllAsync(cancellationToken))\r\n                {\r\n                    // Check if the message is visible to the user\r\n                    if (chatItem.IsUserVisible)\r\n                    {\r\n                        // Handle the message\r\n                        await HandleMessageAsync(chatItem, response, cancellationToken);\r\n                    }\r\n                }\r\n\r\n                await response.WriteAsync($\"event: complete\\ndata: {{}}\\n\\n\", cancellationToken);\r\n                await response.Body.FlushAsync(cancellationToken);               \r\n            \r\n                // Wait for the cancellation token to be triggered\r\n                await Task.Delay(Timeout.Infinite, cancellationToken);\r\n            }\r\n            catch (Exception ex) {\r\n                // Handle any exceptions that occur during streaming\r\n                await response.WriteAsync($\"event: error\\ndata: {{\\\"error\\\": \\\"{ex.Message}\\\"}}\\n\\n\", cancellationToken);\r\n                await response.Body.FlushAsync(cancellationToken);\r\n            }\r\n        });\r\n\r\n\r\n        // Handle incoming messages\r\n        group.MapPost(\"/messages\", async (\r\n            HttpRequest request, \r\n            [FromKeyedServices(\"uploads\")] BlobServiceClient blobServiceClient, \r\n            [FromServices] IChatClient chatClient, \r\n            [FromServices] MessageService messageService,\r\n            [FromServices] ProcessService processService, \r\n            [FromServices] ChatStream chatStream,\r\n            [FromServices] IOptions<UserSettings> userSettings, \r\n            CancellationToken cancellationToken) => \r\n        {\r\n\r\n            // Read request body\r\n            var bodyText = request.Form[\"Text\"].FirstOrDefault() ?? \"\";\r\n            var uploads = await GetFileUploads(userSettings.Value.UserId, request, blobServiceClient, cancellationToken);\r\n\r\n            // Create user message\r\n            var userMessage = new UserMessage(bodyText)\r\n            {\r\n                Attachments = uploads,\r\n                Id = Guid.NewGuid().ToString(),\r\n            };\r\n            \r\n            await messageService.AddMessageAsync(userMessage, userSettings.Value.UserId);\r\n\r\n            // Identify the user's intent\r\n            var reason = await chatClient.GetResponseAsync<UserIntent>($\"Get the user intent: {userMessage.Text}\");\r\n            \r\n            reason.TryGetResult(out var intentResult);\r\n\r\n            // Add the message to the chat stream\r\n            await processService.ActAsync(intentResult, userMessage);\r\n\r\n            return Results.Ok();\r\n        });\r\n\r\n        // TODO: This should enable chat to be restored from history\r\n        group.MapGet(\"/messages\", async (\r\n            [FromKeyedServices(\"history\")] ConcurrentDictionary<string, List<ChatItem>> history,\r\n            [FromServices] ChatStream chatStream,\r\n            [FromQuery] string? userId) =>\r\n        {\r\n            if (string.IsNullOrEmpty(userId))\r\n            {\r\n                return Results.BadRequest(\"User ID is required\");\r\n            }\r\n\r\n            if (!history.TryGetValue(userId, out var messages))\r\n            {\r\n                return Results.NotFound(\"No messages found for the specified user ID\");\r\n            }\r\n\r\n            var visibleMessages = messages.Where(m => m.IsUserVisible).ToList();\r\n            \r\n            return Results.Ok(visibleMessages);\r\n\r\n        });\r\n\r\n        group.MapPost(\"/stream/cancel\", async () =>\r\n        {\r\n            // TODO: Cancel the stream\r\n\r\n            return Results.Ok();\r\n        });\r\n\r\n        \r\n        group.MapPost(\"/messages/clear\", async (\r\n            [FromKeyedServices(\"history\")] ConcurrentDictionary<string, List<ChatItem>> history,\r\n            [FromQuery] string? userId) =>\r\n        {\r\n            if (string.IsNullOrEmpty(userId))\r\n            {\r\n                return Results.BadRequest(\"User ID is required\");\r\n            }\r\n\r\n            // Clear history for the specified user ID\r\n            if (history.TryRemove(userId, out _))\r\n            {\r\n                return Results.Ok(\"History cleared\");\r\n            }\r\n            else\r\n            {\r\n                return Results.NotFound(\"No history found for the specified user ID\");\r\n            }\r\n        });\r\n\r\n        // Select an itinerary option\r\n        group.MapPost(\"/select-itinerary\", async (\r\n            [FromServices] MessageService messageService,\r\n            [FromServices] ProcessService processService,\r\n            [FromServices] ILogger<Program> logger,\r\n            [FromServices] IOptions<UserSettings> userSettings,\r\n            SelectItineraryRequest request,\r\n            CancellationToken cancellationToken) =>\r\n        {\r\n            try \r\n            {\r\n\r\n                var input = new ItinerarySelectedChatItem($\"I have selected an itinerary option. {request.OptionId}\")\r\n                {\r\n                    MessageId = request.MessageId,\r\n                    OptionId = request.OptionId\r\n                };\r\n                \r\n                await messageService.AddMessageAsync(input, userSettings.Value.UserId);\r\n\r\n                await processService.ActAsync(UserIntent.StartTripApproval, input);\r\n\r\n                return Results.Ok();\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                logger.LogError(ex, \"Error selecting itinerary\");\r\n                return Results.Problem(\"Error selecting itinerary\", statusCode: 500);\r\n            }\r\n        });                        \r\n    }\r\n\r\n    private static ChatMessage CreateChatMessageWithAttachments(List<UriAttachment> attachments, string text)\r\n    {\r\n        var content = new List<AIContent>(attachments.Count + 1) { new TextContent(text) };\r\n        foreach (var attachment in attachments)\r\n        {\r\n            if (attachment.Uri.StartsWith(\"data:\"))\r\n            {\r\n                content.Add(new DataContent(attachment.Uri, attachment.ContentType));\r\n            }\r\n            else\r\n            {\r\n                content.Add(new UriContent(attachment.Uri, attachment.ContentType));\r\n            }\r\n        }\r\n\r\n        return new ChatMessage(ChatRole.User, content);\r\n    }\r\n\r\n    private static async Task HandleMessageAsync(ChatItem chatItem, HttpResponse response, CancellationToken cancellationToken)\r\n    {\r\n        try\r\n        {\r\n\r\n            // Handle the message based on its type\r\n            if (chatItem is AssistantResponse assistantResponse)\r\n            {\r\n                // Handle assistant response\r\n                await response.WriteAsync($\"data: {JsonSerializer.Serialize(assistantResponse, JsonSerializerOptions.Web)}\\n\\n\", cancellationToken);\r\n                await response.Body.FlushAsync(cancellationToken);\r\n            }\r\n            else if (chatItem is CandidateItineraryChatItem itineraryItem)\r\n            {\r\n                // Handle candidate itinerary\r\n                var serializedMessage = JsonSerializer.Serialize(itineraryItem, JsonSerializerOptions.Web);\r\n                await response.WriteAsync($\"data: {serializedMessage}\\n\\n\", cancellationToken);\r\n                await response.Body.FlushAsync(cancellationToken);\r\n            }\r\n            else if (chatItem is TripRequestUpdated tripRequestUpdated)\r\n            {\r\n                // Handle trip request update\r\n                var serializedMessage = JsonSerializer.Serialize(tripRequestUpdated, JsonSerializerOptions.Web);\r\n                await response.WriteAsync($\"data: {serializedMessage}\\n\\n\", cancellationToken);\r\n                await response.Body.FlushAsync(cancellationToken);\r\n            }\r\n            else if (chatItem is TripRequestDecisionChatItem tripDecision)\r\n            {\r\n                // Handle trip request decision\r\n                var serializedMessage = JsonSerializer.Serialize(tripDecision, JsonSerializerOptions.Web);\r\n                await response.WriteAsync($\"data: {serializedMessage}\\n\\n\", cancellationToken);\r\n                await response.Body.FlushAsync(cancellationToken);\r\n            }\r\n\r\n            // Handle completion\r\n            await response.WriteAsync($\"event: complete\\ndata: {{}}\\n\\n\", cancellationToken);\r\n            await response.Body.FlushAsync(cancellationToken);\r\n        }\r\n        catch (OperationCanceledException) { }\r\n    }\r\n\r\n    private static async Task<List<UriAttachment>> GetFileUploads(string userId, HttpRequest request, BlobServiceClient blobServiceClient, CancellationToken cancellationToken)\r\n    {\r\n        List<UriAttachment> results = [];\r\n        if (request.HasFormContentType && request.Form.Files.Count > 0)\r\n        {\r\n            foreach (var file in request.Form.Files)\r\n            {\r\n                if (blobServiceClient.AccountName == \"devstoreaccount1\")\r\n                {\r\n                    // These URIs are sent to LLM APIs, which don't have access to the local storage emulator, so we need to convert\r\n                    // them to data URIs in that case.\r\n                    results.Add(new(await ConvertToDataUri(file.OpenReadStream(), file.ContentType, cancellationToken), file.ContentType));\r\n                }\r\n                else\r\n                {\r\n                    results.Add(await UploadToBlobContainerAsync(userId, blobServiceClient, file, cancellationToken));\r\n                }\r\n            }\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    private static async Task<UriAttachment> UploadToBlobContainerAsync(string userId, BlobServiceClient blobServiceClient, IFormFile file, CancellationToken cancellationToken)\r\n    {\r\n        var containerClient = blobServiceClient.GetBlobContainerClient(\"user-content\");\r\n        await containerClient.CreateIfNotExistsAsync(cancellationToken: cancellationToken);\r\n\r\n        var extension = Path.GetExtension(file.FileName) ?? \"jpg\";\r\n        var blobClient = containerClient.GetBlobClient($\"{userId}/{Guid.CreateVersion7():N}.{extension}\");\r\n        await using var stream = file.OpenReadStream();\r\n        await blobClient.UploadAsync(stream, overwrite: true, cancellationToken);\r\n\r\n        var sasBuilder = new BlobSasBuilder\r\n        {\r\n            BlobContainerName = containerClient.Name,\r\n            BlobName = blobClient.Name,\r\n            Resource = \"b\",\r\n            ExpiresOn = DateTimeOffset.MaxValue,\r\n        };\r\n\r\n        sasBuilder.SetPermissions(BlobSasPermissions.Read);\r\n\r\n        if (blobClient.CanGenerateSasUri)\r\n        {\r\n            return new(blobClient.GenerateSasUri(sasBuilder).ToString(), file.ContentType);\r\n        }\r\n        else\r\n        {\r\n            var userDelegationKey = blobServiceClient.GetUserDelegationKey(DateTimeOffset.UtcNow,\r\n                                                                        DateTimeOffset.UtcNow.AddHours(2));\r\n            var blobUriBuilder = new BlobUriBuilder(blobClient.Uri)\r\n            {\r\n                Sas = sasBuilder.ToSasQueryParameters(userDelegationKey, blobServiceClient.AccountName)\r\n            };\r\n\r\n            return new(blobUriBuilder.ToUri().ToString(), file.ContentType);\r\n        }\r\n\r\n        // return new(blobClient.GenerateSasUri(sasBuilder).ToString(), file.ContentType);\r\n    }\r\n\r\n    private static async ValueTask<string> ConvertToDataUri(Stream stream, string contentType, CancellationToken cancellationToken)\r\n    {\r\n        using var memoryStream = new MemoryStream();\r\n        await stream.CopyToAsync(memoryStream, cancellationToken);\r\n        var base64 = Convert.ToBase64String(memoryStream.ToArray());\r\n        return $\"data:{contentType};base64,{base64}\";\r\n    }\r\n\r\n    public record SelectItineraryRequest(string MessageId, string OptionId);    \r\n\r\n    public readonly record struct UriAttachment(string Uri, string ContentType);\r\n}\r\n#pragma warning restore"
    },
    {
      "file": "src/AccedeSimple.Service/Program.cs",
      "description": "The ingestion service points to a PDF document that contains the company policy for reimbursement. This provides the necessary info to the agent to answer questions about expense reports.",
      "line": 74,
      "contents": "#pragma warning disable\r\nusing System.ComponentModel;\r\nusing System.Formats.Asn1;\r\nusing System.Runtime.InteropServices;\r\nusing AccedeSimple.Domain;\r\nusing AccedeSimple.Service.ProcessSteps;\r\nusing Azure.AI.OpenAI;\r\nusing Azure.Identity;\r\nusing Microsoft.Extensions.AI;\r\nusing Microsoft.SemanticKernel;\r\nusing Microsoft.SemanticKernel.Agents;\r\nusing Microsoft.SemanticKernel.ChatCompletion;\r\nusing Microsoft.Extensions.DependencyInjection;\r\nusing Microsoft.Extensions.Hosting;\r\nusing AccedeSimple.Service;\r\nusing Microsoft.AspNetCore.Mvc;\r\nusing ModelContextProtocol.Client;\r\nusing Microsoft.AspNetCore.Http.Features;\r\nusing System.Text.Json.Serialization;\r\nusing System.Text.Json;\r\nusing System.Collections.Concurrent;\r\nusing AccedeSimple.Service.Services;\r\nusing Microsoft.Extensions.VectorData;\r\nusing Microsoft.SemanticKernel.Connectors.SqliteVec;\r\n\r\nvar builder = WebApplication.CreateBuilder(args);\r\n\r\nbuilder.Services.AddHttpClient(\"LocalGuide\", c =>\r\n    {\r\n        c.BaseAddress = new Uri(\"http://localguide\");\r\n    });\r\n\r\n// Load configuration\r\nbuilder.Services.Configure<UserSettings>(builder.Configuration.GetSection(\"UserSettings\"));\r\n\r\n// Add state stores\r\nbuilder.Services.AddSingleton<StateStore>();\r\nbuilder.Services.AddKeyedSingleton<ConcurrentDictionary<string,List<ChatItem>>>(\"history\");\r\n\r\n// Add storage\r\nbuilder.AddKeyedAzureBlobClient(\"uploads\");\r\n\r\n// Configure logging\r\nbuilder.Services.AddLogging();\r\n\r\n// Chat message stream for SSE\r\nbuilder.Services.AddSingleton<ChatStream>();\r\n\r\n// In-memory storage for trip requests\r\nbuilder.Services.AddSingleton<IList<TripRequest>>(new List<TripRequest>());\r\n\r\nbuilder.AddServiceDefaults();\r\n\r\nbuilder.Services.AddMcpClient();\r\n\r\nvar kernel = builder.Services.AddKernel();\r\n\r\nkernel.Services\r\n    .AddChatClient(modelName: Environment.GetEnvironmentVariable(\"MODEL_NAME\") ?? \"gpt-4o-mini\")\r\n    .UseFunctionInvocation();\r\n\r\nkernel.Services.AddEmbeddingGenerator(modelName: \"text-embedding-3-small\");\r\nkernel.Services.AddSqliteCollection<int, Document>(\"Documents\", \"Data Source=documents.db\");\r\nkernel.Services.AddTransient<ProcessService>();\r\nkernel.Services.AddTransient<MessageService>();\r\nkernel.Services.AddTransient<SearchService>();\r\n\r\nbuilder.Services.AddTravelProcess();\r\n\r\nvar app = builder.Build();\r\n\r\nvar k = app.Services.GetRequiredService<Kernel>();\r\nvar collection = k.GetRequiredService<VectorStoreCollection<int, Document>>();\r\nvar IngestionService = new IngestionService(collection);\r\nawait IngestionService.IngestAsync(Path.Combine(AppContext.BaseDirectory, \"docs\"));\r\n\r\napp.MapEndpoints();\r\n\r\napp.Run();\r\n\r\npublic class UserSettings\r\n{\r\n    public string UserId { get; set; }\r\n    public string AdminUserId { get; set; }\r\n\r\n}"
    },
    {
      "file": "src/AccedeSimple.Service/Services/SearchService.cs",
      "description": "The vector store uses the embeddings to determine relevant results from the data the application has been augmented with.",
      "line": 16,
      "contents": "using Microsoft.Extensions.AI;\r\nusing Microsoft.Extensions.VectorData;\r\n\r\nnamespace AccedeSimple.Service.Services;\r\n\r\npublic class SearchService\r\n{\r\n    private readonly VectorStoreCollection<int, Document> _collection;\r\n    public SearchService(VectorStoreCollection<int, Document> collection)\r\n    {\r\n        _collection = collection;\r\n    }\r\n\r\n    public async IAsyncEnumerable<Document> SearchAsync(string query)\r\n    {\r\n        await foreach (var result in _collection.SearchAsync(query, top: 5))\r\n        { \r\n            yield return result.Record;\r\n        }\r\n    }\r\n}"
    },
    {
      "file": "src/AccedeSimple.Service/ChatStream.cs",
      "description": "Our AI building blocks handle multi-modal with ease. Here, it is simply added a different content type to the response. You can use data-encoded URIs or pass a byte array of image data to send images to the model. ",
      "line": 70,
      "contents": "using System.Diagnostics.CodeAnalysis;\r\nusing System.Reactive.Linq;\r\nusing System.Reactive.Subjects;\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\nusing AccedeSimple.Domain;\r\nusing Microsoft.Extensions.AI;\r\nusing static AccedeSimple.Service.Endpoints;\r\n\r\nnamespace AccedeSimple.Service;\r\n\r\npublic class ChatStream\r\n{\r\n    private readonly Subject<ChatItem> _messageSubject = new();\r\n    \r\n    // private int _nextIndex = 0;\r\n\r\n    public IObservable<ChatItem> Messages => _messageSubject.AsObservable();\r\n\r\n    public void AddMessage(ChatItem item)\r\n    {\r\n        _messageSubject.OnNext(item);\r\n    }\r\n}\r\n\r\n[JsonPolymorphic(TypeDiscriminatorPropertyName = \"$type\")]\r\n[JsonDerivedType(typeof(UserMessage), \"user\")]\r\n[JsonDerivedType(typeof(AssistantResponse), \"assistant\")]\r\n[JsonDerivedType(typeof(CandidateItineraryChatItem), \"candidate-itineraries\")]\r\n[JsonDerivedType(typeof(TripRequestUpdated), \"trip-request-updated\")]\r\n[JsonDerivedType(typeof(ItinerarySelectedChatItem), \"itinerary-selected\")]\r\n[JsonDerivedType(typeof(TripRequestDecisionChatItem), \"trip-approval-result\")]\r\npublic abstract class ChatItem(string text)\r\n{\r\n\r\n    public string Text { get; init; } = text;\r\n\r\n    public string? Id { get; init; }\r\n\r\n    public abstract ChatRole Role { get; }\r\n\r\n    public abstract string Type { get; }\r\n\r\n    [JsonIgnore]\r\n    public abstract bool IsUserVisible { get; }\r\n\r\n    public virtual ChatMessage? ToChatMessage() => new ChatMessage(Role, Text);\r\n\r\n    [JsonIgnore]\r\n    internal bool IsUserMessage => Role == ChatRole.User;\r\n}\r\n\r\n// User messages\r\npublic sealed class UserMessage(string text) : ChatItem(text)\r\n{\r\n    public override string Type => \"user\";\r\n    public override ChatRole Role => ChatRole.User;\r\n    public override bool IsUserVisible => true;\r\n\r\n    public List<UriAttachment>? Attachments { get; init; }\r\n\r\n    public override ChatMessage? ToChatMessage() => Attachments switch\r\n    {\r\n        { Count: > 0 } attachments => CreateChatMessageWithAttachments(attachments),\r\n        _ => base.ToChatMessage(),\r\n    };\r\n\r\n    private ChatMessage CreateChatMessageWithAttachments(List<UriAttachment> attachments)\r\n    {\r\n        var content = new List<AIContent>(attachments.Count + 1) { new TextContent(Text) };\r\n        foreach (var attachment in attachments)\r\n        {\r\n            if (attachment.Uri.StartsWith(\"data:\"))\r\n            {\r\n                content.Add(new DataContent(attachment.Uri, attachment.ContentType));\r\n            }\r\n            else\r\n            {\r\n                content.Add(new UriContent(attachment.Uri, attachment.ContentType));\r\n            }\r\n        }\r\n\r\n        return new ChatMessage(ChatRole.User, content);\r\n    }\r\n}\r\n\r\n\r\n// Assistant messages\r\npublic class AssistantResponse : ChatItem\r\n{\r\n    [SetsRequiredMembers]\r\n    public AssistantResponse(string text) : base(text)\r\n    {\r\n        var id = Guid.NewGuid().ToString();\r\n        Id = id;\r\n        ResponseId = id;\r\n    }\r\n\r\n    public override string Type => \"assistant\";\r\n\r\n    public string? ResponseId { get; set; }\r\n    public bool IsFinal { get; set; } = true;\r\n    public override ChatRole Role => ChatRole.Assistant;\r\n    public override bool IsUserVisible => true;\r\n}\r\n\r\n\r\n// Candidate itinerary messages\r\npublic class CandidateItineraryChatItem : ChatItem\r\n{\r\n    [SetsRequiredMembers]\r\n    public CandidateItineraryChatItem(string text, List<TripOption> options) : base(text)\r\n    {\r\n        Id = Guid.NewGuid().ToString();\r\n        Options = options;\r\n    }\r\n\r\n    public List<TripOption> Options { get; }\r\n    public override string Type => \"candidate-itineraries\";\r\n    public override ChatRole Role => ChatRole.Assistant;\r\n    public override bool IsUserVisible => true;\r\n    public override ChatMessage? ToChatMessage()\r\n    {\r\n        var text =\r\n            $\"\"\"\r\n            Here are the trips matching your requirements:\r\n\r\n            {string.Join(\"\\n\", Options.Select(option => JsonSerializer.Serialize(option, JsonSerializerOptions.Web)))}\r\n            \"\"\";\r\n        return new ChatMessage(ChatRole.User, text);\r\n    }\r\n}\r\n\r\n// Trip request messages\r\npublic sealed class TripRequestUpdated(string text) : ChatItem(text)\r\n{\r\n    public override string Type => \"trip-request-updated\";\r\n    public override ChatRole Role => ChatRole.Assistant;\r\n    public override bool IsUserVisible => true;\r\n    public override ChatMessage? ToChatMessage() => null;\r\n}\r\n\r\n// Itinerary selected messages\r\npublic class ItinerarySelectedChatItem(string text) : ChatItem(text)\r\n{\r\n    public required string MessageId { get; init; }\r\n\r\n    public required string OptionId { get; init; }\r\n\r\n    public override string Type => \"itinerary-selected\";\r\n    public override ChatRole Role => ChatRole.User;\r\n    public override bool IsUserVisible => false;\r\n    public override ChatMessage? ToChatMessage() =>\r\n        new ChatMessage(ChatRole.User, $\"I've selected itinerary option {OptionId}.\");\r\n}\r\n\r\n// Trip request result messages\r\npublic class TripRequestDecisionChatItem : ChatItem\r\n{\r\n    [SetsRequiredMembers]\r\n    public TripRequestDecisionChatItem(TripRequestResult result) : base(GetTextForStatus(result.Status))\r\n    {\r\n        Id = Guid.NewGuid().ToString();\r\n        Result = result;\r\n    }\r\n    public TripRequestResult Result { get; }\r\n    public override string Type => \"trip-approval-result\";\r\n    public override ChatRole Role => ChatRole.Assistant;\r\n    public override bool IsUserVisible => true;\r\n    public override ChatMessage? ToChatMessage() => new ChatMessage(ChatRole.User, Text);\r\n    private static string GetTextForStatus(TripRequestStatus status) => status switch\r\n    {\r\n        TripRequestStatus.Approved => \"Trip request approved.\",\r\n        TripRequestStatus.Rejected => \"Trip request rejected.\",\r\n        _ => throw new NotSupportedException($\"Unsupported trip request status: {status}\")\r\n    };\r\n}"
    },
    {
      "file": "src/AccedeSimple.Domain/Shared/ReceiptData.cs",
      "description": "This is the data we wish to extract from receipts.",
      "line": 5,
      "contents": "using System;\r\n\r\nnamespace AccedeSimple.Domain\r\n{\r\n    public record ReceiptData\r\n    {\r\n        public string Id { get; init; } = string.Empty;\r\n        public string Description { get; init; } = string.Empty;\r\n        public decimal Amount { get; init; }\r\n        public ExpenseCategory Category { get; init; }\r\n        public DateTime? Date { get; init; }\r\n        public string ImageUrl { get; init; } = string.Empty;\r\n\r\n        public ReceiptData WithCategory(ExpenseCategory newCategory) =>\r\n            this with { Category = newCategory };\r\n\r\n        public ReceiptData WithAmount(decimal newAmount) =>\r\n            this with { Amount = newAmount };\r\n    }\r\n}"
    },
    {
      "file": "src/AccedeSimple.Service/ProcessSteps/ReceiptProcessingStep.cs",
      "description": "...and here is the simple request to have it parsed out! We simply uploaded the file, encoded it as a data URI, then passed it to the agent with structured output.",
      "line": 41,
      "contents": "#pragma warning disable\r\nusing Microsoft.SemanticKernel;\r\nusing Microsoft.SemanticKernel.ChatCompletion;\r\nusing System.Threading.Tasks;\r\nusing AccedeSimple.Domain;\r\nusing Microsoft.Extensions.AI;\r\nusing Microsoft.SemanticKernel.Connectors.OpenAI;\r\nusing System.ComponentModel;\r\nusing System.Text.Json;\r\nusing Microsoft.Extensions.Options;\r\nusing AccedeSimple.Service.Services;\r\n\r\nnamespace AccedeSimple.Service.ProcessSteps;\r\n\r\npublic class ReceiptProcessingStep : KernelProcessStep\r\n{\r\n    private IChatClient _chatClient;\r\n    private StateStore _state;\r\n    private readonly MessageService _messageService;\r\n    private readonly UserSettings _userSettings;\r\n\r\n    public ReceiptProcessingStep(\r\n        IChatClient chatClient,\r\n        StateStore state,\r\n        MessageService messageService,\r\n        IOptions<UserSettings> userSettings)\r\n    {\r\n        _chatClient = chatClient;\r\n        _state = state;\r\n        _messageService = messageService;\r\n        _userSettings = userSettings.Value;\r\n    }\r\n\r\n    [KernelFunction(\"ProcessReceiptsAsync\")]\r\n    [Description(\"Process receipts for expense compliance and categorization.\")]\r\n    public async Task ProcessReceiptsAsync(\r\n        UserMessage userInput,\r\n        KernelProcessStepContext context)\r\n    {\r\n\r\n        var receiptResponse = await _chatClient.GetResponseAsync<List<ReceiptData>>(userInput.ToChatMessage());\r\n\r\n        receiptResponse.TryGetResult(out var receipts);\r\n\r\n        // Update state with processed receipts\r\n        _state.Set(\"receipts\", receipts);\r\n\r\n        // await context.EmitEventAsync(\"ReceiptsProcessed\");\r\n        await _messageService.AddMessageAsync(new AssistantResponse(\"Receipts processed successfully.\"), _userSettings.UserId);\r\n    }\r\n}"
    },
    {
      "file": "src/AccedeSimple.Service/ProcessSteps/TravelPlanningStep.cs",
      "description": "Model Context Protocol is like OpenAPI but for agents. It publishes its capabilities and provides context for how to interact with it.",
      "line": 7,
      "contents": "#pragma warning disable\r\nusing System.Text.Json;\r\nusing Microsoft.Extensions.AI;\r\nusing Microsoft.SemanticKernel;\r\nusing AccedeSimple.Domain;\r\nusing System.ComponentModel;\r\nusing ModelContextProtocol.Client;\r\nusing Microsoft.AspNetCore.Mvc;\r\nusing Azure;\r\nusing AccedeSimple.Service.Services;\r\nusing Microsoft.Extensions.Options;\r\n\r\nnamespace AccedeSimple.Service.ProcessSteps;\r\n\r\npublic class TravelPlanningStep : KernelProcessStep\r\n{\r\n    private StateStore _state = new();\r\n    \r\n    private readonly IChatClient _chatClient;\r\n    private readonly ILogger<TravelPlanningStep> _logger;\r\n    private readonly IMcpClient _mcpClient;\r\n\r\n    private readonly MessageService _messageService;\r\n    \r\n    private readonly UserSettings _userSettings;\r\n\r\n\r\n    public TravelPlanningStep(\r\n        ILogger<TravelPlanningStep> logger,\r\n        IChatClient chatClient,\r\n        IMcpClient mcpClient,\r\n        MessageService messageService,\r\n        StateStore stateStore,\r\n        IOptions<UserSettings> userSettings)\r\n    {\r\n        _chatClient = chatClient;\r\n        _logger = logger;\r\n        _mcpClient = mcpClient;\r\n        _messageService = messageService;\r\n        _userSettings = userSettings.Value;\r\n        _state = stateStore;\r\n    }\r\n\r\n\r\n    [KernelFunction(\"PlanTripAsync\")]\r\n    [Description(\"Generate trip options based on user preferences and parameters.\")]\r\n    public async Task<List<TripOption>> PlanTripAsync(\r\n        ChatItem userInput,\r\n        KernelProcessStepContext context)\r\n    {\r\n\r\n        // Generate new trip parameters\r\n        var tripParameterPrompt = \r\n            $\"\"\"\r\n            You are a travel assistant. Your task is to generate trip parameters based on the user input.\r\n\r\n            The user has provided the following information:\r\n\r\n            {userInput.Text}\r\n\r\n            Today's date is: {DateTime.Now.ToString()}\r\n\r\n            Generate trip parameters\r\n            \"\"\";\r\n\r\n\r\n        var res = await _chatClient.GetResponseAsync<TripParameters>(tripParameterPrompt);\r\n\r\n        res.TryGetResult(out var tripParameters);\r\n\r\n\r\n        List<ChatMessage> messages = [\r\n            new ChatMessage(ChatRole.User,\r\n                $\"\"\"\r\n                You are a travel planning assistant. Generate trip options based on the provided parameters. \r\n\r\n                {JsonSerializer.Serialize(tripParameters)}\r\n\r\n                Consider factors like cost, convenience, and preferences. Each option should include: \r\n                - Flight details (departure/arrival times, airline, price)\r\n                - Hotel options (location, check-in/out dates, price)\r\n                - Car rental options if requested\r\n\r\n                Ensure that there is a variety of options to choose from, including different airlines, hotels, and car rental companies.\r\n                \r\n                Generate at least 3 different trip options with a detailed breakdown of each option.\r\n\r\n                Ensure that dates are formatted correctly.\r\n                \"\"\")                   \r\n        ];\r\n\r\n        var tools = await _mcpClient.ListToolsAsync();\r\n\r\n        await _messageService.AddMessageAsync(new TripRequestUpdated(\"Planning your trip...\"), _userSettings.UserId);\r\n\r\n        var response = await _chatClient.GetResponseAsync<List<TripOption>>(\r\n            messages,\r\n            new ChatOptions { \r\n                Temperature = 0.7f,\r\n                Tools = [.. tools ]\r\n        });\r\n\r\n        response.TryGetResult(out var result);\r\n\r\n        // Update state with trip options\r\n        _state.Set(\"trip-options\", result);\r\n\r\n        // Write the result to the chat stream\r\n        // _chatStream.AddMessage();\r\n        await _messageService.AddMessageAsync(\r\n            new CandidateItineraryChatItem(\"Here are trips matching your requirements.\", result),\r\n            _userSettings.UserId);\r\n\r\n        var options = result ?? [];\r\n\r\n        return options;\r\n    }\r\n\r\n    [KernelFunction(\"CreateTripRequestAsync\")]\r\n    [Description(\"Create a trip request based on the selected travel option.\")]\r\n    public async Task<TripRequest> CreateTripRequestAsync(\r\n        ChatItem userInput,\r\n        KernelProcessStepContext context)\r\n    {        \r\n\r\n        var options = _state.Get(\"trip-options\").Value as List<TripOption>;\r\n        var tripRequestPrompt = \r\n            $\"\"\"\r\n            You are a travel assistant. Create a formal trip request based on the selected travel option.\r\n            Include all necessary details for approval.\r\n\r\n            # Trip Options\r\n            {JsonSerializer.Serialize(options)}\r\n\r\n            # Selected Travel Option\r\n            {userInput.Text}\r\n            \"\"\";\r\n\r\n        var tripRequestResponse = await _chatClient.GetResponseAsync<TripRequest>(tripRequestPrompt);\r\n        \r\n        tripRequestResponse.TryGetResult(out var tripRequest);\r\n\r\n        _state.Set(\"trip-requests\", new List<TripRequest> { tripRequest });\r\n\r\n        // Write the result to the chat stream\r\n        // _chatStream.AddMessage(new AssistantResponse(\"Admin Approval Needed\"));\r\n        await _messageService.AddMessageAsync(\r\n            new AssistantResponse(\"Trip request created. Awaiting admin approval.\"),\r\n            _userSettings.UserId);\r\n\r\n        return tripRequest;\r\n    }\r\n}"
    },
    {
      "file": "src/AccedeSimple.Service/ProcessSteps/TravelPlanningStep.cs",
      "description": "This is the heart of the MCP implementation. We simply use structured data to shape the request, then MCP provides the available tools, and the agent is able to synthesize the users request with the booking services to generate an itinerary.",
      "line": 96,
      "contents": "#pragma warning disable\r\nusing System.Text.Json;\r\nusing Microsoft.Extensions.AI;\r\nusing Microsoft.SemanticKernel;\r\nusing AccedeSimple.Domain;\r\nusing System.ComponentModel;\r\nusing ModelContextProtocol.Client;\r\nusing Microsoft.AspNetCore.Mvc;\r\nusing Azure;\r\nusing AccedeSimple.Service.Services;\r\nusing Microsoft.Extensions.Options;\r\n\r\nnamespace AccedeSimple.Service.ProcessSteps;\r\n\r\npublic class TravelPlanningStep : KernelProcessStep\r\n{\r\n    private StateStore _state = new();\r\n    \r\n    private readonly IChatClient _chatClient;\r\n    private readonly ILogger<TravelPlanningStep> _logger;\r\n    private readonly IMcpClient _mcpClient;\r\n\r\n    private readonly MessageService _messageService;\r\n    \r\n    private readonly UserSettings _userSettings;\r\n\r\n\r\n    public TravelPlanningStep(\r\n        ILogger<TravelPlanningStep> logger,\r\n        IChatClient chatClient,\r\n        IMcpClient mcpClient,\r\n        MessageService messageService,\r\n        StateStore stateStore,\r\n        IOptions<UserSettings> userSettings)\r\n    {\r\n        _chatClient = chatClient;\r\n        _logger = logger;\r\n        _mcpClient = mcpClient;\r\n        _messageService = messageService;\r\n        _userSettings = userSettings.Value;\r\n        _state = stateStore;\r\n    }\r\n\r\n\r\n    [KernelFunction(\"PlanTripAsync\")]\r\n    [Description(\"Generate trip options based on user preferences and parameters.\")]\r\n    public async Task<List<TripOption>> PlanTripAsync(\r\n        ChatItem userInput,\r\n        KernelProcessStepContext context)\r\n    {\r\n\r\n        // Generate new trip parameters\r\n        var tripParameterPrompt = \r\n            $\"\"\"\r\n            You are a travel assistant. Your task is to generate trip parameters based on the user input.\r\n\r\n            The user has provided the following information:\r\n\r\n            {userInput.Text}\r\n\r\n            Today's date is: {DateTime.Now.ToString()}\r\n\r\n            Generate trip parameters\r\n            \"\"\";\r\n\r\n\r\n        var res = await _chatClient.GetResponseAsync<TripParameters>(tripParameterPrompt);\r\n\r\n        res.TryGetResult(out var tripParameters);\r\n\r\n\r\n        List<ChatMessage> messages = [\r\n            new ChatMessage(ChatRole.User,\r\n                $\"\"\"\r\n                You are a travel planning assistant. Generate trip options based on the provided parameters. \r\n\r\n                {JsonSerializer.Serialize(tripParameters)}\r\n\r\n                Consider factors like cost, convenience, and preferences. Each option should include: \r\n                - Flight details (departure/arrival times, airline, price)\r\n                - Hotel options (location, check-in/out dates, price)\r\n                - Car rental options if requested\r\n\r\n                Ensure that there is a variety of options to choose from, including different airlines, hotels, and car rental companies.\r\n                \r\n                Generate at least 3 different trip options with a detailed breakdown of each option.\r\n\r\n                Ensure that dates are formatted correctly.\r\n                \"\"\")                   \r\n        ];\r\n\r\n        var tools = await _mcpClient.ListToolsAsync();\r\n\r\n        await _messageService.AddMessageAsync(new TripRequestUpdated(\"Planning your trip...\"), _userSettings.UserId);\r\n\r\n        var response = await _chatClient.GetResponseAsync<List<TripOption>>(\r\n            messages,\r\n            new ChatOptions { \r\n                Temperature = 0.7f,\r\n                Tools = [.. tools ]\r\n        });\r\n\r\n        response.TryGetResult(out var result);\r\n\r\n        // Update state with trip options\r\n        _state.Set(\"trip-options\", result);\r\n\r\n        // Write the result to the chat stream\r\n        // _chatStream.AddMessage();\r\n        await _messageService.AddMessageAsync(\r\n            new CandidateItineraryChatItem(\"Here are trips matching your requirements.\", result),\r\n            _userSettings.UserId);\r\n\r\n        var options = result ?? [];\r\n\r\n        return options;\r\n    }\r\n\r\n    [KernelFunction(\"CreateTripRequestAsync\")]\r\n    [Description(\"Create a trip request based on the selected travel option.\")]\r\n    public async Task<TripRequest> CreateTripRequestAsync(\r\n        ChatItem userInput,\r\n        KernelProcessStepContext context)\r\n    {        \r\n\r\n        var options = _state.Get(\"trip-options\").Value as List<TripOption>;\r\n        var tripRequestPrompt = \r\n            $\"\"\"\r\n            You are a travel assistant. Create a formal trip request based on the selected travel option.\r\n            Include all necessary details for approval.\r\n\r\n            # Trip Options\r\n            {JsonSerializer.Serialize(options)}\r\n\r\n            # Selected Travel Option\r\n            {userInput.Text}\r\n            \"\"\";\r\n\r\n        var tripRequestResponse = await _chatClient.GetResponseAsync<TripRequest>(tripRequestPrompt);\r\n        \r\n        tripRequestResponse.TryGetResult(out var tripRequest);\r\n\r\n        _state.Set(\"trip-requests\", new List<TripRequest> { tripRequest });\r\n\r\n        // Write the result to the chat stream\r\n        // _chatStream.AddMessage(new AssistantResponse(\"Admin Approval Needed\"));\r\n        await _messageService.AddMessageAsync(\r\n            new AssistantResponse(\"Trip request created. Awaiting admin approval.\"),\r\n            _userSettings.UserId);\r\n\r\n        return tripRequest;\r\n    }\r\n}"
    },
    {
      "file": "src/AccedeSimple.Service/ProcessSteps/TravelPlanningStep.cs",
      "description": "This isn't all MCP can do. Let's take a look at something a little different for a moment...",
      "line": 116,
      "contents": "#pragma warning disable\r\nusing System.Text.Json;\r\nusing Microsoft.Extensions.AI;\r\nusing Microsoft.SemanticKernel;\r\nusing AccedeSimple.Domain;\r\nusing System.ComponentModel;\r\nusing ModelContextProtocol.Client;\r\nusing Microsoft.AspNetCore.Mvc;\r\nusing Azure;\r\nusing AccedeSimple.Service.Services;\r\nusing Microsoft.Extensions.Options;\r\n\r\nnamespace AccedeSimple.Service.ProcessSteps;\r\n\r\npublic class TravelPlanningStep : KernelProcessStep\r\n{\r\n    private StateStore _state = new();\r\n    \r\n    private readonly IChatClient _chatClient;\r\n    private readonly ILogger<TravelPlanningStep> _logger;\r\n    private readonly IMcpClient _mcpClient;\r\n\r\n    private readonly MessageService _messageService;\r\n    \r\n    private readonly UserSettings _userSettings;\r\n\r\n\r\n    public TravelPlanningStep(\r\n        ILogger<TravelPlanningStep> logger,\r\n        IChatClient chatClient,\r\n        IMcpClient mcpClient,\r\n        MessageService messageService,\r\n        StateStore stateStore,\r\n        IOptions<UserSettings> userSettings)\r\n    {\r\n        _chatClient = chatClient;\r\n        _logger = logger;\r\n        _mcpClient = mcpClient;\r\n        _messageService = messageService;\r\n        _userSettings = userSettings.Value;\r\n        _state = stateStore;\r\n    }\r\n\r\n\r\n    [KernelFunction(\"PlanTripAsync\")]\r\n    [Description(\"Generate trip options based on user preferences and parameters.\")]\r\n    public async Task<List<TripOption>> PlanTripAsync(\r\n        ChatItem userInput,\r\n        KernelProcessStepContext context)\r\n    {\r\n\r\n        // Generate new trip parameters\r\n        var tripParameterPrompt = \r\n            $\"\"\"\r\n            You are a travel assistant. Your task is to generate trip parameters based on the user input.\r\n\r\n            The user has provided the following information:\r\n\r\n            {userInput.Text}\r\n\r\n            Today's date is: {DateTime.Now.ToString()}\r\n\r\n            Generate trip parameters\r\n            \"\"\";\r\n\r\n\r\n        var res = await _chatClient.GetResponseAsync<TripParameters>(tripParameterPrompt);\r\n\r\n        res.TryGetResult(out var tripParameters);\r\n\r\n\r\n        List<ChatMessage> messages = [\r\n            new ChatMessage(ChatRole.User,\r\n                $\"\"\"\r\n                You are a travel planning assistant. Generate trip options based on the provided parameters. \r\n\r\n                {JsonSerializer.Serialize(tripParameters)}\r\n\r\n                Consider factors like cost, convenience, and preferences. Each option should include: \r\n                - Flight details (departure/arrival times, airline, price)\r\n                - Hotel options (location, check-in/out dates, price)\r\n                - Car rental options if requested\r\n\r\n                Ensure that there is a variety of options to choose from, including different airlines, hotels, and car rental companies.\r\n                \r\n                Generate at least 3 different trip options with a detailed breakdown of each option.\r\n\r\n                Ensure that dates are formatted correctly.\r\n                \"\"\")                   \r\n        ];\r\n\r\n        var tools = await _mcpClient.ListToolsAsync();\r\n\r\n        await _messageService.AddMessageAsync(new TripRequestUpdated(\"Planning your trip...\"), _userSettings.UserId);\r\n\r\n        var response = await _chatClient.GetResponseAsync<List<TripOption>>(\r\n            messages,\r\n            new ChatOptions { \r\n                Temperature = 0.7f,\r\n                Tools = [.. tools ]\r\n        });\r\n\r\n        response.TryGetResult(out var result);\r\n\r\n        // Update state with trip options\r\n        _state.Set(\"trip-options\", result);\r\n\r\n        // Write the result to the chat stream\r\n        // _chatStream.AddMessage();\r\n        await _messageService.AddMessageAsync(\r\n            new CandidateItineraryChatItem(\"Here are trips matching your requirements.\", result),\r\n            _userSettings.UserId);\r\n\r\n        var options = result ?? [];\r\n\r\n        return options;\r\n    }\r\n\r\n    [KernelFunction(\"CreateTripRequestAsync\")]\r\n    [Description(\"Create a trip request based on the selected travel option.\")]\r\n    public async Task<TripRequest> CreateTripRequestAsync(\r\n        ChatItem userInput,\r\n        KernelProcessStepContext context)\r\n    {        \r\n\r\n        var options = _state.Get(\"trip-options\").Value as List<TripOption>;\r\n        var tripRequestPrompt = \r\n            $\"\"\"\r\n            You are a travel assistant. Create a formal trip request based on the selected travel option.\r\n            Include all necessary details for approval.\r\n\r\n            # Trip Options\r\n            {JsonSerializer.Serialize(options)}\r\n\r\n            # Selected Travel Option\r\n            {userInput.Text}\r\n            \"\"\";\r\n\r\n        var tripRequestResponse = await _chatClient.GetResponseAsync<TripRequest>(tripRequestPrompt);\r\n        \r\n        tripRequestResponse.TryGetResult(out var tripRequest);\r\n\r\n        _state.Set(\"trip-requests\", new List<TripRequest> { tripRequest });\r\n\r\n        // Write the result to the chat stream\r\n        // _chatStream.AddMessage(new AssistantResponse(\"Admin Approval Needed\"));\r\n        await _messageService.AddMessageAsync(\r\n            new AssistantResponse(\"Trip request created. Awaiting admin approval.\"),\r\n            _userSettings.UserId);\r\n\r\n        return tripRequest;\r\n    }\r\n}"
    },
    {
      "file": "src/AccedeSimple.Service/Endpoints.cs",
      "description": "Agents are great for automating common tasks, but often we want verification and human approval. Here, we're saying \"let a human approve the itinerary\" as part of a long-running, stateful workflow for the itinerary.",
      "line": 57,
      "contents": "#pragma warning disable\r\nusing System.Collections.Concurrent;\r\nusing System.Text.Json;\r\nusing System.Threading.Channels;\r\nusing AccedeSimple.Domain;\r\nusing AccedeSimple.Service.ProcessSteps;\r\nusing AccedeSimple.Service.Services;\r\nusing Azure.Storage.Blobs;\r\nusing Azure.Storage.Sas;\r\nusing Microsoft.AspNetCore.Http.Features;\r\nusing Microsoft.AspNetCore.Mvc;\r\nusing Microsoft.Extensions.AI;\r\nusing Microsoft.Extensions.Options;\r\nusing Microsoft.SemanticKernel;\r\nusing OpenTelemetry.Trace;\r\nusing TextContent = Microsoft.Extensions.AI.TextContent;\r\n\r\nnamespace AccedeSimple.Service;\r\npublic static class Endpoints\r\n{\r\n\r\n    public static void MapEndpoints(this WebApplication app)\r\n    {\r\n        app.MapEndpoints(\"/api/admin\", group => group.MapAdminEndpoints());\r\n        app.MapEndpoints(\"/api/chat\", group => group.MapChatEndpoints());\r\n    }\r\n\r\n    private static void MapEndpoints(this WebApplication app, string basePath, Action<RouteGroupBuilder> configure)\r\n    {\r\n        var group = app.MapGroup(basePath);\r\n        configure(group);\r\n    }\r\n\r\n    private static void MapAdminEndpoints(this RouteGroupBuilder group)\r\n    {\r\n        // var group = app.MapGroup(\"/api/admin\");\r\n\r\n        // Get pending trip approval requests\r\n        group.MapGet(\"/requests\", async (\r\n            [FromServices] StateStore store,\r\n            [FromServices] ILogger<Program> logger, \r\n            CancellationToken cancellationToken) =>\r\n        {\r\n            try\r\n            {\r\n                var requests = store.Get(\"trip-requests\").Value as List<TripRequest>;\r\n                return Results.Ok(requests);\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                logger.LogError(ex, \"Error fetching trip requests\");\r\n                return Results.Problem(\"Error fetching trip requests\", statusCode: 500);\r\n            }\r\n        });\r\n\r\n        // Approve or reject a trip request\r\n        group.MapPost(\"/requests/approval\", async (\r\n            [FromServices] Kernel kernel, \r\n            [FromServices] KernelProcess process, \r\n            [FromServices] ILogger<Program> logger,\r\n            TripRequestResult result, \r\n            CancellationToken cancellationToken) =>\r\n        {\r\n            try\r\n            {\r\n                await process.StartAsync(kernel, new KernelProcessEvent { Id = nameof(ApprovalStep.HandleApprovalResponseAsync), Data = result });\r\n                return Results.Ok();\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                logger.LogError(ex, \"Error submitting trip request result\");\r\n                return Results.Problem(\"Error submitting trip request result\", statusCode: 500);\r\n            }\r\n        });        \r\n    }\r\n\r\n    private static void MapChatEndpoints(this RouteGroupBuilder group)\r\n    {\r\n\r\n        // Stream responses back to the client\r\n        group.MapGet(\"/stream\", async (\r\n            int? startIndex, \r\n            [FromServices] ChatStream chatStream, \r\n            HttpResponse response, \r\n            CancellationToken cancellationToken) => \r\n        {\r\n            // Create a channel to handle incoming messages\r\n            var channel = Channel.CreateUnbounded<ChatItem>();\r\n\r\n            // Disable response buffering\r\n            var bufferingFeature = response.HttpContext.Features.Get<IHttpResponseBodyFeature>();\r\n            bufferingFeature?.DisableBuffering();    \r\n\r\n            // Set SSE headers\r\n            response.Headers.Add(\"Content-Type\", \"text/event-stream\");\r\n            response.Headers.Add(\"Cache-Control\", \"no-cache, no-store\");\r\n            response.Headers.Add(\"Connection\", \"keep-alive\");\r\n\r\n            // Initialize connected event\r\n            await response.WriteAsync($\"event: connected\\ndata: {{\\\"connected\\\": true}}\\n\\n\", cancellationToken);\r\n            await response.Body.FlushAsync(cancellationToken);\r\n            try\r\n            {\r\n                // Subscribe to the chat stream\r\n                var subscription = \r\n                    chatStream\r\n                        .Messages\r\n                        .Subscribe(msg => channel.Writer.TryWrite(msg));\r\n\r\n                // Read from the channel and write to the response\r\n                await foreach (var chatItem in channel.Reader.ReadAllAsync(cancellationToken))\r\n                {\r\n                    // Check if the message is visible to the user\r\n                    if (chatItem.IsUserVisible)\r\n                    {\r\n                        // Handle the message\r\n                        await HandleMessageAsync(chatItem, response, cancellationToken);\r\n                    }\r\n                }\r\n\r\n                await response.WriteAsync($\"event: complete\\ndata: {{}}\\n\\n\", cancellationToken);\r\n                await response.Body.FlushAsync(cancellationToken);               \r\n            \r\n                // Wait for the cancellation token to be triggered\r\n                await Task.Delay(Timeout.Infinite, cancellationToken);\r\n            }\r\n            catch (Exception ex) {\r\n                // Handle any exceptions that occur during streaming\r\n                await response.WriteAsync($\"event: error\\ndata: {{\\\"error\\\": \\\"{ex.Message}\\\"}}\\n\\n\", cancellationToken);\r\n                await response.Body.FlushAsync(cancellationToken);\r\n            }\r\n        });\r\n\r\n\r\n        // Handle incoming messages\r\n        group.MapPost(\"/messages\", async (\r\n            HttpRequest request, \r\n            [FromKeyedServices(\"uploads\")] BlobServiceClient blobServiceClient, \r\n            [FromServices] IChatClient chatClient, \r\n            [FromServices] MessageService messageService,\r\n            [FromServices] ProcessService processService, \r\n            [FromServices] ChatStream chatStream,\r\n            [FromServices] IOptions<UserSettings> userSettings, \r\n            CancellationToken cancellationToken) => \r\n        {\r\n\r\n            // Read request body\r\n            var bodyText = request.Form[\"Text\"].FirstOrDefault() ?? \"\";\r\n            var uploads = await GetFileUploads(userSettings.Value.UserId, request, blobServiceClient, cancellationToken);\r\n\r\n            // Create user message\r\n            var userMessage = new UserMessage(bodyText)\r\n            {\r\n                Attachments = uploads,\r\n                Id = Guid.NewGuid().ToString(),\r\n            };\r\n            \r\n            await messageService.AddMessageAsync(userMessage, userSettings.Value.UserId);\r\n\r\n            // Identify the user's intent\r\n            var reason = await chatClient.GetResponseAsync<UserIntent>($\"Get the user intent: {userMessage.Text}\");\r\n            \r\n            reason.TryGetResult(out var intentResult);\r\n\r\n            // Add the message to the chat stream\r\n            await processService.ActAsync(intentResult, userMessage);\r\n\r\n            return Results.Ok();\r\n        });\r\n\r\n        // TODO: This should enable chat to be restored from history\r\n        group.MapGet(\"/messages\", async (\r\n            [FromKeyedServices(\"history\")] ConcurrentDictionary<string, List<ChatItem>> history,\r\n            [FromServices] ChatStream chatStream,\r\n            [FromQuery] string? userId) =>\r\n        {\r\n            if (string.IsNullOrEmpty(userId))\r\n            {\r\n                return Results.BadRequest(\"User ID is required\");\r\n            }\r\n\r\n            if (!history.TryGetValue(userId, out var messages))\r\n            {\r\n                return Results.NotFound(\"No messages found for the specified user ID\");\r\n            }\r\n\r\n            var visibleMessages = messages.Where(m => m.IsUserVisible).ToList();\r\n            \r\n            return Results.Ok(visibleMessages);\r\n\r\n        });\r\n\r\n        group.MapPost(\"/stream/cancel\", async () =>\r\n        {\r\n            // TODO: Cancel the stream\r\n\r\n            return Results.Ok();\r\n        });\r\n\r\n        \r\n        group.MapPost(\"/messages/clear\", async (\r\n            [FromKeyedServices(\"history\")] ConcurrentDictionary<string, List<ChatItem>> history,\r\n            [FromQuery] string? userId) =>\r\n        {\r\n            if (string.IsNullOrEmpty(userId))\r\n            {\r\n                return Results.BadRequest(\"User ID is required\");\r\n            }\r\n\r\n            // Clear history for the specified user ID\r\n            if (history.TryRemove(userId, out _))\r\n            {\r\n                return Results.Ok(\"History cleared\");\r\n            }\r\n            else\r\n            {\r\n                return Results.NotFound(\"No history found for the specified user ID\");\r\n            }\r\n        });\r\n\r\n        // Select an itinerary option\r\n        group.MapPost(\"/select-itinerary\", async (\r\n            [FromServices] MessageService messageService,\r\n            [FromServices] ProcessService processService,\r\n            [FromServices] ILogger<Program> logger,\r\n            [FromServices] IOptions<UserSettings> userSettings,\r\n            SelectItineraryRequest request,\r\n            CancellationToken cancellationToken) =>\r\n        {\r\n            try \r\n            {\r\n\r\n                var input = new ItinerarySelectedChatItem($\"I have selected an itinerary option. {request.OptionId}\")\r\n                {\r\n                    MessageId = request.MessageId,\r\n                    OptionId = request.OptionId\r\n                };\r\n                \r\n                await messageService.AddMessageAsync(input, userSettings.Value.UserId);\r\n\r\n                await processService.ActAsync(UserIntent.StartTripApproval, input);\r\n\r\n                return Results.Ok();\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                logger.LogError(ex, \"Error selecting itinerary\");\r\n                return Results.Problem(\"Error selecting itinerary\", statusCode: 500);\r\n            }\r\n        });                        \r\n    }\r\n\r\n    private static ChatMessage CreateChatMessageWithAttachments(List<UriAttachment> attachments, string text)\r\n    {\r\n        var content = new List<AIContent>(attachments.Count + 1) { new TextContent(text) };\r\n        foreach (var attachment in attachments)\r\n        {\r\n            if (attachment.Uri.StartsWith(\"data:\"))\r\n            {\r\n                content.Add(new DataContent(attachment.Uri, attachment.ContentType));\r\n            }\r\n            else\r\n            {\r\n                content.Add(new UriContent(attachment.Uri, attachment.ContentType));\r\n            }\r\n        }\r\n\r\n        return new ChatMessage(ChatRole.User, content);\r\n    }\r\n\r\n    private static async Task HandleMessageAsync(ChatItem chatItem, HttpResponse response, CancellationToken cancellationToken)\r\n    {\r\n        try\r\n        {\r\n\r\n            // Handle the message based on its type\r\n            if (chatItem is AssistantResponse assistantResponse)\r\n            {\r\n                // Handle assistant response\r\n                await response.WriteAsync($\"data: {JsonSerializer.Serialize(assistantResponse, JsonSerializerOptions.Web)}\\n\\n\", cancellationToken);\r\n                await response.Body.FlushAsync(cancellationToken);\r\n            }\r\n            else if (chatItem is CandidateItineraryChatItem itineraryItem)\r\n            {\r\n                // Handle candidate itinerary\r\n                var serializedMessage = JsonSerializer.Serialize(itineraryItem, JsonSerializerOptions.Web);\r\n                await response.WriteAsync($\"data: {serializedMessage}\\n\\n\", cancellationToken);\r\n                await response.Body.FlushAsync(cancellationToken);\r\n            }\r\n            else if (chatItem is TripRequestUpdated tripRequestUpdated)\r\n            {\r\n                // Handle trip request update\r\n                var serializedMessage = JsonSerializer.Serialize(tripRequestUpdated, JsonSerializerOptions.Web);\r\n                await response.WriteAsync($\"data: {serializedMessage}\\n\\n\", cancellationToken);\r\n                await response.Body.FlushAsync(cancellationToken);\r\n            }\r\n            else if (chatItem is TripRequestDecisionChatItem tripDecision)\r\n            {\r\n                // Handle trip request decision\r\n                var serializedMessage = JsonSerializer.Serialize(tripDecision, JsonSerializerOptions.Web);\r\n                await response.WriteAsync($\"data: {serializedMessage}\\n\\n\", cancellationToken);\r\n                await response.Body.FlushAsync(cancellationToken);\r\n            }\r\n\r\n            // Handle completion\r\n            await response.WriteAsync($\"event: complete\\ndata: {{}}\\n\\n\", cancellationToken);\r\n            await response.Body.FlushAsync(cancellationToken);\r\n        }\r\n        catch (OperationCanceledException) { }\r\n    }\r\n\r\n    private static async Task<List<UriAttachment>> GetFileUploads(string userId, HttpRequest request, BlobServiceClient blobServiceClient, CancellationToken cancellationToken)\r\n    {\r\n        List<UriAttachment> results = [];\r\n        if (request.HasFormContentType && request.Form.Files.Count > 0)\r\n        {\r\n            foreach (var file in request.Form.Files)\r\n            {\r\n                if (blobServiceClient.AccountName == \"devstoreaccount1\")\r\n                {\r\n                    // These URIs are sent to LLM APIs, which don't have access to the local storage emulator, so we need to convert\r\n                    // them to data URIs in that case.\r\n                    results.Add(new(await ConvertToDataUri(file.OpenReadStream(), file.ContentType, cancellationToken), file.ContentType));\r\n                }\r\n                else\r\n                {\r\n                    results.Add(await UploadToBlobContainerAsync(userId, blobServiceClient, file, cancellationToken));\r\n                }\r\n            }\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    private static async Task<UriAttachment> UploadToBlobContainerAsync(string userId, BlobServiceClient blobServiceClient, IFormFile file, CancellationToken cancellationToken)\r\n    {\r\n        var containerClient = blobServiceClient.GetBlobContainerClient(\"user-content\");\r\n        await containerClient.CreateIfNotExistsAsync(cancellationToken: cancellationToken);\r\n\r\n        var extension = Path.GetExtension(file.FileName) ?? \"jpg\";\r\n        var blobClient = containerClient.GetBlobClient($\"{userId}/{Guid.CreateVersion7():N}.{extension}\");\r\n        await using var stream = file.OpenReadStream();\r\n        await blobClient.UploadAsync(stream, overwrite: true, cancellationToken);\r\n\r\n        var sasBuilder = new BlobSasBuilder\r\n        {\r\n            BlobContainerName = containerClient.Name,\r\n            BlobName = blobClient.Name,\r\n            Resource = \"b\",\r\n            ExpiresOn = DateTimeOffset.MaxValue,\r\n        };\r\n\r\n        sasBuilder.SetPermissions(BlobSasPermissions.Read);\r\n\r\n        if (blobClient.CanGenerateSasUri)\r\n        {\r\n            return new(blobClient.GenerateSasUri(sasBuilder).ToString(), file.ContentType);\r\n        }\r\n        else\r\n        {\r\n            var userDelegationKey = blobServiceClient.GetUserDelegationKey(DateTimeOffset.UtcNow,\r\n                                                                        DateTimeOffset.UtcNow.AddHours(2));\r\n            var blobUriBuilder = new BlobUriBuilder(blobClient.Uri)\r\n            {\r\n                Sas = sasBuilder.ToSasQueryParameters(userDelegationKey, blobServiceClient.AccountName)\r\n            };\r\n\r\n            return new(blobUriBuilder.ToUri().ToString(), file.ContentType);\r\n        }\r\n\r\n        // return new(blobClient.GenerateSasUri(sasBuilder).ToString(), file.ContentType);\r\n    }\r\n\r\n    private static async ValueTask<string> ConvertToDataUri(Stream stream, string contentType, CancellationToken cancellationToken)\r\n    {\r\n        using var memoryStream = new MemoryStream();\r\n        await stream.CopyToAsync(memoryStream, cancellationToken);\r\n        var base64 = Convert.ToBase64String(memoryStream.ToArray());\r\n        return $\"data:{contentType};base64,{base64}\";\r\n    }\r\n\r\n    public record SelectItineraryRequest(string MessageId, string OptionId);    \r\n\r\n    public readonly record struct UriAttachment(string Uri, string ContentType);\r\n}\r\n#pragma warning restore"
    },
    {
      "file": "src/AccedeSimple.Service/ProcessSteps/ApprovalStep.cs",
      "description": "Here's the approval step in our workflow.",
      "line": 39,
      "contents": "#pragma warning disable\r\nusing System.Text.Json;\r\nusing Microsoft.Extensions.AI;\r\nusing Microsoft.SemanticKernel;\r\nusing AccedeSimple.Domain;\r\nusing System.ComponentModel;\r\nusing AccedeSimple.Service.Services;\r\nusing Microsoft.Extensions.Options;\r\n\r\nnamespace AccedeSimple.Service.ProcessSteps;\r\n\r\npublic class ApprovalStep : KernelProcessStep\r\n{\r\n    private StateStore _state = new();\r\n    private readonly UserSettings _userSettings;\r\n    private readonly IList<TripRequest> _requests;\r\n    private readonly MessageService _messageService;\r\n    private readonly IChatClient _chatClient;\r\n\r\n    public ApprovalStep(\r\n        IChatClient _chatClient,\r\n        MessageService messageService,\r\n        IOptions<UserSettings> userSettings,\r\n        StateStore state)\r\n    {\r\n        _chatClient = _chatClient;\r\n        _messageService = messageService;\r\n        _state = state;\r\n        _userSettings = userSettings.Value;\r\n\r\n    }\r\n\r\n    [KernelFunction(\"ProcessApprovalAsync\")]\r\n    [Description(\"Process the trip request for approval.\")]\r\n    public async Task ProcessApprovalAsync(\r\n        ItinerarySelectedChatItem userInput,\r\n        KernelProcessStepContext context)\r\n    {\r\n        var input = userInput;\r\n\r\n        var options = _state.Get(\"trip-options\").Value as List<TripOption>;\r\n\r\n        var selectedOption = options.Where(o => o.OptionId == input.OptionId);\r\n\r\n        var generateTripRequestPrompt =\r\n            $\"\"\"\r\n            Create a formal trip request based on the selected travel option.\r\n            Include all necessary details for approval:\r\n\r\n            # Trip Option\r\n            \r\n            {JsonSerializer.Serialize(selectedOption)}\r\n            \"\"\";\r\n\r\n        var tripResponse = await _chatClient.GetResponseAsync<TripRequest>(generateTripRequestPrompt);\r\n\r\n        tripResponse.TryGetResult(out var tripRequest);\r\n\r\n        _state.Set(\"trip-requests\", new List<TripRequest> { tripRequest });\r\n    }\r\n            \r\n\r\n    [KernelFunction(\"HandleApprovalResponseAsync\")]\r\n    [Description(\"Handle the admin's approval or rejection of the trip request.\")]\r\n    public async Task HandleApprovalResponseAsync(\r\n        TripRequestResult result,\r\n        KernelProcessStepContext context)\r\n    {\r\n        // Safely remove the request from the list\r\n        var requests = _state.Get(\"trip-requests\").Value as List<TripRequest>;\r\n\r\n        var request = requests?.FirstOrDefault(r => r.RequestId == result.RequestId);\r\n\r\n        if (request != null)\r\n        {\r\n            requests.Remove(request);\r\n            _state.Set(\"trip-requests\", requests);\r\n        }\r\n\r\n        await _messageService.AddMessageAsync(new TripRequestDecisionChatItem(result), _userSettings.UserId);\r\n    }\r\n}\r\n#pragma warning restore"
    },
    {
      "file": "src/AccedeSimple.Service/Services/ProcessService.cs",
      "description": "Here, we're using the Semantic Kernel Process framework to define our workflow and orchestrate the steps through code.",
      "line": 39,
      "contents": "#pragma warning disable\r\nusing System.Text.Json;\r\nusing AccedeSimple.Domain;\r\nusing AccedeSimple.Service.ProcessSteps;\r\nusing Microsoft.Extensions.AI;\r\nusing Microsoft.Extensions.Options;\r\nusing Microsoft.SemanticKernel;\r\n\r\nnamespace AccedeSimple.Service.Services;\r\n\r\npublic class ProcessService\r\n{\r\n    private readonly Kernel _kernel;\r\n    private readonly KernelProcess _process;\r\n    private readonly MessageService _messageService;\r\n\r\n    private readonly IChatClient _chatClient;\r\n    private readonly UserSettings _userSettings;\r\n    private readonly HttpClient _httpClient;\r\n\r\n    public ProcessService(\r\n        Kernel kernel, \r\n        KernelProcess process, \r\n        MessageService messageService, \r\n        IChatClient chatClient,\r\n        IOptions<UserSettings> userSettings,\r\n        IHttpClientFactory httpClientFactory)\r\n    {\r\n        _kernel = kernel;\r\n        _process = process;\r\n        _messageService = messageService;\r\n        _chatClient = chatClient;\r\n        _userSettings = userSettings.Value;\r\n        _httpClient = httpClientFactory.CreateClient(\"LocalGuide\");\r\n    }\r\n\r\n    public async Task ActAsync(UserIntent userIntent, ChatItem userInput)\r\n    {\r\n        switch (userIntent)\r\n        {\r\n            case UserIntent.General:\r\n                // Handle general inquiries\r\n                var response = await _chatClient.GetResponseAsync(userInput.ToChatMessage());\r\n                await _messageService.AddMessageAsync(new AssistantResponse(response.Text), _userSettings.UserId);\r\n                break;\r\n            case UserIntent.AskLocalGuide:\r\n                // Handle local guide inquiries\r\n                var builder = new UriBuilder(_httpClient.BaseAddress)\r\n                {\r\n                    Path = \"attractions\",\r\n                    Query = $\"query={Uri.EscapeDataString(userInput.Text)}\"\r\n                };             \r\n                var localGuideRequest = await _httpClient.SendAsync(new HttpRequestMessage(HttpMethod.Post, builder.Uri));\r\n                var body = await localGuideRequest.Content.ReadAsStringAsync();\r\n                await _messageService.AddMessageAsync(new AssistantResponse(body), _userSettings.UserId);\r\n                break;\r\n            case UserIntent.AskPolicyQuestions:\r\n                await _process.StartAsync(_kernel, new KernelProcessEvent { Id = nameof(PolicyInquiryStep.ProcessPolicyInquiryAsync), Data = userInput });\r\n                break;\r\n            case UserIntent.StartTravelPlanning:\r\n                await _process.StartAsync(_kernel, new KernelProcessEvent { Id = nameof(TravelPlanningStep.PlanTripAsync), Data = userInput });\r\n                break;\r\n            case UserIntent.StartTripApproval:\r\n                await _process.StartAsync(_kernel, new KernelProcessEvent { Id = nameof(TravelPlanningStep.CreateTripRequestAsync), Data = userInput });\r\n                break;\r\n            case UserIntent.ProcessReceipts:\r\n                await _process.StartAsync(_kernel, new KernelProcessEvent { Id = nameof(ReceiptProcessingStep.ProcessReceiptsAsync), Data = userInput });\r\n                break;\r\n            case UserIntent.GenerateExpenseReport:\r\n                await _process.StartAsync(_kernel, new KernelProcessEvent { Id = nameof(ExpenseReportStep.GenerateExpenseReportAsync) });\r\n                break;\r\n            default:\r\n                await _messageService.AddMessageAsync(new AssistantResponse(\"Unknown intent. Please clarify your request.\"), _userSettings.UserId);\r\n                break;\r\n        }\r\n    }\r\n}\r\n#pragma warning restore"
    },
    {
      "file": "src/localguide/main.py",
      "description": "With .NET Aspire, resources don't have to be .NET-based. We are running a polyglot environment which includes a Python service. Not a problem! Our tools are here to integrate all of the pieces you have so you can use the right solution for the right part of the problem.",
      "line": 15,
      "contents": "from fastapi import FastAPI, HTTPException\r\nimport uvicorn\r\nfrom pydantic import BaseModel\r\nfrom pydantic_ai import Agent\r\nfrom pydantic_ai.models.openai import OpenAIModel\r\nfrom pydantic_ai.providers.openai import OpenAIProvider\r\nimport os\r\nfrom openai import AsyncAzureOpenAI\r\nfrom azure.identity import (\r\n    DefaultAzureCredential,\r\n    get_bearer_token_provider\r\n)\r\n\r\n# Define Pydantic models\r\nclass Attraction(BaseModel):\r\n    name: str\r\n    description: str\r\n    address: str\r\n    rating: float\r\n    operating_hours: str\r\n\r\nclass CityAttractions(BaseModel):\r\n    city: str\r\n    attractions: list[Attraction]\r\n\r\n# Initialize FastAPI app\r\napp = FastAPI()\r\n\r\n# Root endpoint\r\n@app.get(\"/\")\r\nasync def root():\r\n    return {\"message\": \"FastAPI is running\"}\r\n\r\n# Initialize the Agent\r\nazure_credential = DefaultAzureCredential()\r\ntoken_provider = get_bearer_token_provider(azure_credential, \"https://cognitiveservices.azure.com/.default\")\r\n\r\nclient = AsyncAzureOpenAI(\r\n    azure_endpoint=os.environ.get(\"AZURE_OPENAI_ENDPOINT\"),\r\n    azure_ad_token_provider=token_provider,\r\n    api_version=\"2024-06-01\"\r\n)\r\n\r\nmodel_name = os.environ.get(\"MODEL_NAME\", \"gpt-4o-mini\")\r\nmodel = OpenAIModel(model_name, provider=OpenAIProvider(openai_client=client))\r\nagent = Agent(model, \r\n              output_type=CityAttractions,\r\n              system_prompt=\"You are an expert local guide. Provide detailed information about attractions in the specified city.\")\r\n\r\n# Endpoint to get attractions for a city\r\n@app.post(\"/attractions\")\r\nasync def get_attractions(query: str):\r\n    try:\r\n        # Use the agent asynchronously to fetch attractions\r\n        structured_result = await agent.run(f\"{query}\")\r\n\r\n        # Use the model to provide a more user-friendly response\r\n        result = await agent.run(f\"\"\"Please provide a detailed list of attractions in {structured_result.output.city} with the \r\n                                 following details: \r\n                                 {structured_result.output.attractions}\"\"\", \r\n                                 output_type=str)\r\n        \r\n        return result.output\r\n    except Exception as e:\r\n        raise HTTPException(status_code=500, detail=str(e))\r\n    \r\n# start app\r\nif __name__ == \"__main__\":\r\n    port = int(os.environ.get('PORT', 8000))\r\n    uvicorn.run(app, host=\"0.0.0.0\", port=port)"
    },
    {
      "file": "src/AccedeSimple.AppHost/Program.cs",
      "description": "You don't have to use .NET Aspire to build distributed intelligent applications. The benefits, however, are definitely worth considering. Let's take a look at the Aspire dashboard. ",
      "line": 4,
      "contents": "#pragma warning disable\r\nusing Microsoft.Extensions.Hosting;\r\n\r\nvar builder = DistributedApplication.CreateBuilder(args);\r\n\r\n// Define parameters for Azure OpenAI\r\nvar azureOpenAIResource = builder.AddParameterFromConfiguration(\"AzureOpenAIResourceName\", \"AzureOpenAI:ResourceName\");\r\nvar azureOpenAIResourceGroup = builder.AddParameterFromConfiguration(\"AzureOpenAIResourceGroup\",\"AzureOpenAI:ResourceGroup\");\r\nvar azureOpenAIEndpoint = builder.AddParameterFromConfiguration(\"AzureOpenAIEndpoint\", \"AzureOpenAI:Endpoint\");\r\nvar modelName = \"gpt-4.1\";\r\n\r\n\r\n// Configure Azure Services\r\nvar azureStorage = builder.AddAzureStorage(\"storage\");\r\nvar openai = \r\n    builder.AddAzureOpenAI(\"openai\")\r\n        .AsExisting(azureOpenAIResource, azureOpenAIResourceGroup);\r\n\r\nif (builder.Environment.IsDevelopment())\r\n{\r\n    azureStorage.RunAsEmulator(c => {\r\n        c.WithDataBindMount();\r\n        c.WithLifetime(ContainerLifetime.Persistent);\r\n    });    \r\n}\r\n\r\n// Configure projects\r\nvar mcpServer =\r\n    builder.AddProject<Projects.AccedeSimple_MCPServer>(\"mcpserver\")\r\n        .WithReference(openai)\r\n        .WithEnvironment(\"MODEL_NAME\", modelName)\r\n        .WaitFor(openai);\r\n\r\n\r\nvar pythonApp =\r\n    builder.AddPythonApp(\"localguide\", \"../localguide\", \"main.py\")\r\n        .WithHttpEndpoint(env: \"PORT\", port: 8000, isProxied: false)\r\n        .WithEnvironment(\"AZURE_OPENAI_ENDPOINT\", azureOpenAIEndpoint)\r\n        .WithEnvironment(\"MODEL_NAME\", modelName)\r\n        .WithOtlpExporter()\r\n        .WaitFor(openai);\r\n\r\nvar backend =\r\n    builder\r\n        .AddProject<Projects.AccedeSimple_Service>(\"backend\")\r\n        .WithReference(openai)\r\n        .WithReference(mcpServer)\r\n        .WithReference(pythonApp)\r\n        .WithReference(azureStorage.AddBlobs(\"uploads\"))\r\n        .WithEnvironment(\"MODEL_NAME\", modelName)\r\n        .WaitFor(openai);\r\n\r\nbuilder.AddNpmApp(\"webui\", \"../webui\")\r\n    .WithNpmPackageInstallation()\r\n    .WithHttpEndpoint(env: \"PORT\", port: 35_369, isProxied: false)\r\n    .WithEnvironment(\"BACKEND_URL\", backend.GetEndpoint(\"http\"))\r\n    .WithExternalHttpEndpoints()\r\n    .WithOtlpExporter()\r\n    .WaitFor(backend)\r\n    .PublishAsDockerFile();\r\n\r\nbuilder.Build().Run();\r\n#pragma warning restore"
    },
    {
      "file": "src/AccedeSimple.AppHost/Program.cs",
      "description": "All of your Aspire resources can be easily transitioned into resources for seamless deployment to Azure - often with just two steps!",
      "line": 62,
      "contents": "#pragma warning disable\r\nusing Microsoft.Extensions.Hosting;\r\n\r\nvar builder = DistributedApplication.CreateBuilder(args);\r\n\r\n// Define parameters for Azure OpenAI\r\nvar azureOpenAIResource = builder.AddParameterFromConfiguration(\"AzureOpenAIResourceName\", \"AzureOpenAI:ResourceName\");\r\nvar azureOpenAIResourceGroup = builder.AddParameterFromConfiguration(\"AzureOpenAIResourceGroup\",\"AzureOpenAI:ResourceGroup\");\r\nvar azureOpenAIEndpoint = builder.AddParameterFromConfiguration(\"AzureOpenAIEndpoint\", \"AzureOpenAI:Endpoint\");\r\nvar modelName = \"gpt-4.1\";\r\n\r\n\r\n// Configure Azure Services\r\nvar azureStorage = builder.AddAzureStorage(\"storage\");\r\nvar openai = \r\n    builder.AddAzureOpenAI(\"openai\")\r\n        .AsExisting(azureOpenAIResource, azureOpenAIResourceGroup);\r\n\r\nif (builder.Environment.IsDevelopment())\r\n{\r\n    azureStorage.RunAsEmulator(c => {\r\n        c.WithDataBindMount();\r\n        c.WithLifetime(ContainerLifetime.Persistent);\r\n    });    \r\n}\r\n\r\n// Configure projects\r\nvar mcpServer =\r\n    builder.AddProject<Projects.AccedeSimple_MCPServer>(\"mcpserver\")\r\n        .WithReference(openai)\r\n        .WithEnvironment(\"MODEL_NAME\", modelName)\r\n        .WaitFor(openai);\r\n\r\n\r\nvar pythonApp =\r\n    builder.AddPythonApp(\"localguide\", \"../localguide\", \"main.py\")\r\n        .WithHttpEndpoint(env: \"PORT\", port: 8000, isProxied: false)\r\n        .WithEnvironment(\"AZURE_OPENAI_ENDPOINT\", azureOpenAIEndpoint)\r\n        .WithEnvironment(\"MODEL_NAME\", modelName)\r\n        .WithOtlpExporter()\r\n        .WaitFor(openai);\r\n\r\nvar backend =\r\n    builder\r\n        .AddProject<Projects.AccedeSimple_Service>(\"backend\")\r\n        .WithReference(openai)\r\n        .WithReference(mcpServer)\r\n        .WithReference(pythonApp)\r\n        .WithReference(azureStorage.AddBlobs(\"uploads\"))\r\n        .WithEnvironment(\"MODEL_NAME\", modelName)\r\n        .WaitFor(openai);\r\n\r\nbuilder.AddNpmApp(\"webui\", \"../webui\")\r\n    .WithNpmPackageInstallation()\r\n    .WithHttpEndpoint(env: \"PORT\", port: 35_369, isProxied: false)\r\n    .WithEnvironment(\"BACKEND_URL\", backend.GetEndpoint(\"http\"))\r\n    .WithExternalHttpEndpoints()\r\n    .WithOtlpExporter()\r\n    .WaitFor(backend)\r\n    .PublishAsDockerFile();\r\n\r\nbuilder.Build().Run();\r\n#pragma warning restore"
    }
  ]
}